<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="361"/>

<div>
<span><div>flex布局是我们学到的一种新的布局方式，他和display:block等属性一样，只不过不要与block那些属性混淆。这个就是单独的一个display:flex</div><div><br/></div><div>首先我们想让元素成为弹性盒子，第一个要做的事就是开启弹性盒子属性，也就是在加上“display:flex”这个属性。加上这个属性的盒子就会让其下的子元素改变原先的排列位置，变成一种新的布局格式：</div><div><img src="flex_files/Image.png" type="image/png" style="height: auto;"/></div><div><img src="flex_files/Image [1].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>这个表现形式就是我们开启弹性布局以后的表现形式，这里有几点一定要知道和注意的地方：</div><ol><li>当我们开启了弹性布局以后，会默认出现两条轴（如图所示），起始点和终止点有标注。</li><li>如果我们没有进行任何别的操作，那么主轴默认的方向就是X轴的方向。</li><li>副轴仅仅只是垂直于主轴，他们并没有明确的方向关系问题，就只是垂直而已。</li><li>他们的起始点和终止点就是我们父级盒子的边。</li><li>其下所有的子元素默认会在一行排列，不会换行，如果一行放不下的时候，会将盒子进行挤压，但是最小就只能挤压到子级盒子中内容的大小，不会在进行挤压，如果还是放不下的会就只能让子级盒子溢出父级盒子，但是绝对不会让子级盒子中的内容溢出子级盒子。</li></ol><div>接下来我们就来说一下开启弹性布局以后我们都可以做一些什么。</div><div><br/></div><div>一、<span style="color: rgb(255, 0, 0);">可以改变主轴的方向</span></div><div>我们可以改变主轴的方向，因为副轴永远是垂直于主轴的，所以我们只要改变了主轴方向就等于是改变了副轴的方向，在这里我们用flex-direction这个属性来改变主轴的方向。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>{</div><div><div>    flex-direction: row;<br/></div>
    flex-direction: column;</div><div>    flex-direction: row-reverse;</div><div>    flex-direction: column-reverse;</div><div>}</div></div><div><br/></div><div>        row //-&gt; 是默认的格式，就是我们一开始的开启弹性盒子的时候的默认格式。</div><div><img src="flex_files/Image [2].png" type="image/png" style="height: auto;"/></div><div>        column//-&gt; 把主轴方向改变成从左上角开始垂直向下。</div><div><img src="flex_files/Image [3].png" type="image/png" style="height: auto;"/></div><div>        row-reverse //-&gt; 将主轴翻转，把之前主轴结束位变成开始为，之前的开始位变为结束位。</div><div><img src="flex_files/Image [4].png" type="image/png" style="height: auto;"/></div><div>        column-reverse //-&gt; 在主轴方向变成垂直向下以后，把之前主轴结束位变成开始为，之前的开始位变为结束位。</div><div><img src="flex_files/Image [5].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>这个就是我们改变主轴方向的操作，这里要注意的是，不管主轴怎么改变方向，我们在接下来说道的方法中，该是操作主轴的还是操作主轴的，只是我们要看清主轴到底是冲向哪个方向。</div><div>接下来的笔记全部是以主轴默认的方向演示（其他方向道理一样，可以自己尝试一下）</div><div><br/></div><div>二、改变默认的一行排列</div><div>因为我们的弹性布局默认是会进行一行排列的，在这里我们通过flex-wrap属性开启可以换行的操作。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>{</div><div>    flex-wrap: nowrap;</div><div>    flex-wrap: wrap;</div><div>}</div></div><div><br/></div><div>        flex-wrap: nowrap; //-&gt; 是默认值，元素不可以换行，如果放不下了就会讲子级盒子压缩，最小压缩到子盒子中内容的大小</div><div><img src="flex_files/Image [6].png" type="image/png" style="height: auto;"/></div><div>        flex-wrap: wrap; //-&gt; 开启换行，让元素在一行显示不下的时候换行</div><div><img src="flex_files/Image [7].png" type="image/png" style="height: auto;"/></div><div>这个就是换行属性的表现形式，但是这个换行以后会出现一些小问题，也是需要我们注意的。这些小问题因为是和后面我们讲到的一些属性有关系，所以我们把问题在下面的属性中提到。</div><div><br/></div><div>三、<span style="color: rgb(255, 0, 0);">我们可以改变所有元素在主轴上的排布方式</span></div><div>我们使用的是justify-content属性，这个属性是让其下的子级盒子在主轴的方向上的排列方式（共有五种方式）。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>{</div><div>    justify-content: flex-start;</div><div>    justify-content: flex-end;</div><div>    justify-content: center;</div><div>    justify-content: space-between;</div><div>    justify-content: space-around;</div><div>}</div></div><div><br/></div><div>        flex-start //-&gt; 让所有元素以主轴起始点对齐</div><div><img src="flex_files/Image [8].png" type="image/png" style="height: auto;"/></div><div>        flex-end //-&gt; 让所有元素以主轴终止点对齐</div><div><img src="flex_files/Image [9].png" type="image/png" style="height: auto;"/></div><div>        center //-&gt; 让所有元素以主轴中间点对齐</div><div><img src="flex_files/Image [10].png" type="image/png" style="height: auto;"/></div><div>        space-between //-&gt; 让元素以两侧顶格，中间每个元素与每个元素之间的间距相同的方式对齐</div><div><img src="flex_files/Image [11].png" type="image/png" style="height: auto;"/></div><div>        space-around //-&gt; 让元素以环绕的方式进行对齐（每一个元素两侧的留白全部一样）</div><div><img src="flex_files/Image [12].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>这就是主轴方向排列的几种表现形式。</div><div><br/></div><div>四、<span style="color: rgb(255, 0, 0);">我们可以改变元素在副轴上的排布方式</span></div><div>在这里要注意的一点就是，我们改变元素在副轴上的排布方式的时候，是分成两种情况来设置的，一种是副轴排布上只有一行，第二种就是换行开启后，副轴上出现多行的情况。</div><div>这里说一个小技巧：我们在进行flex布局的时候，先设置主轴方向的排布方式，然后我们可以把已经设置好主轴排布方式的那<b><span style="color: rgb(255, 70, 53);">一排元素当成一个整体来看</span></b>（这个说法也只是帮助我们理解而已） ，这样我们就好理解的多了。在<b><span style="color: rgb(255, 0, 0);">允许换行后，并且没有设置align-content属性之前</span></b>我们也可以把每一排元素都当成一个个的整体元素来看就可以了（这个必须牢记。这里一定要注意这种状态是<span style="color: rgb(255, 0, 0);"><b>允许换行后，并且没有设置align-content属性之前</b></span>才会出现的。牢记，牢记，牢记！！！ ）</div><div><img src="flex_files/Image [13].png" type="image/png" style="height: auto;"/></div><div>这个图只是帮助我们记忆而已，当然，一定要注意，这只是一个默认状态，当我们允许换行后，并且设置了align-content属性之后，这个状态就会消失了，会变成另外一种状态。（另外一种状态一会我们再介绍）</div><div>现在，我们先来说一下只有一行的时候，我们使用align-items这个属性设置的元素在副轴上的排布方式。（这里我们默认的主轴排布方式是justify-content: space-between;）</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>{</div><div>    align-items: flex-start;</div><div>    align-items: flex-end;</div><div>    align-items: center;</div><div>    align-items: stretch;<br/></div><div>}</div></div><div><br/></div><div>        align-items: flex-start; //-&gt; 把我们刚才当成一个整体看的那个元素放在副轴的起始点</div><div><img src="flex_files/Image [14].png" type="image/png" style="height: auto;"/></div><div>        align-items: flex-end; //-&gt; 把我们刚才当成一个整体看的那个元素放在副轴的终止点</div><div><img src="flex_files/Image [15].png" type="image/png" style="height: auto;"/></div><div>        align-items: center; //-&gt; 把我们刚才当成一个整体看的那个元素放在副轴的中间位置</div><div><img src="flex_files/Image [16].png" type="image/png" style="height: auto;"/></div><div>        align-items: stretch; //-&gt; 把我们刚才当成一个整体看的那个元素拉伸成与副轴一样长度的元素（这个设置只有在子元素没有设置与副轴对应的元素值的情况下才可以生效，不然没有效果。比如现在副轴是垂直向下的，如果我们没有设置元素的高，那么我们的元素的高就会变成副轴的长度，也就是拉伸至上下顶格。如果我们通过改变主轴方向而使得副轴方向水平向右时，我们如果不设置元素的宽，那么宽度就会变成副轴的长度，也就是拉伸至左右顶格。<span style="color: rgb(255, 0, 0);"><b>如果我们给元素的宽和高都设置了值的话，那么这个属性讲不会再生效</b></span>。）</div><div><img src="flex_files/Image [17].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>这就是我们的元素在副轴上的排布方式，不过这个只是单行的操作，我们只要把这一行元素当成一个整体来看就好了。</div><div>接下来我们说一下多行的情况。刚才我们看到过了，多行的时候会出现“两条主轴”，这个时候我们对主轴和副轴的操作都是两行或者多行都参照这一个规则，并且在自己的当前行，按照这个规则进行移动。（这里我们justify-content: space-between; 排布）</div><div>语法和表现形式都和单行的时候一样，只不过只是在自己当前行，所以就不一一写出来了，只看一个align-items: center 的表现形式就好了。</div><div><img src="flex_files/Image [18].png" type="image/png" style="height: auto;"/></div><div>我们设置的主轴方向排布justify-content: space-between;  是每一行元素都会在当前行的主轴上按照这个方式进行排布。</div><div>我们设置的副轴方向排布align-items: center;  是每一行元素都会在当前的副轴上按照这个方式进行排布。</div><div>这个就是多行时的默认状态下的操作，如果我们允许换行以后，并且设置了align-content这个属性以后，这个默认的排布方式就被抵消掉了，就会按照一种新的方式进行排布。（接下来我们还以两行为例，并且主轴的排布方式还是justify-content: space-between;）</div><div>主轴和副轴都会回归到只有一条的状态，并且align-items属性不会再生效。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>{</div><div>    align-content: flex-start;</div><div>    align-content: flex-end;</div><div>    align-content: center;</div><div>    align-content: space-between;</div><div>    align-content: space-around;<br/></div><div>}</div></div><div><br/></div><div>        align-content: flex-start;  //-&gt; 把多行元素按照副轴起始点开始顺序排列</div><div><img src="flex_files/Image [19].png" type="image/png"/></div><div>        align-content: flex-end;  //-&gt; 把多行元素按照副轴终止点结束顺序排列</div><div><img src="flex_files/Image [20].png" type="image/png"/></div><div>        align-content: center; //-&gt; 把多行元素集中在副轴中间点的位置</div><div><img src="flex_files/Image [21].png" type="image/png"/></div><div>        align-content: space-between; //-&gt; 把多行元素按照副轴两边顶格，中间间隔一样的方式排列</div><div><img src="flex_files/Image [22].png" type="image/png"/></div><div>        align-content: space-around; //-&gt; 把多行元素按照副轴方向环绕的方式进行排列</div><div><img src="flex_files/Image [23].png" type="image/png"/></div><div>这个时候我们可以发现，这个多行的副轴方向排布就和主轴方向排布的表现形式是一模一样的。我们要注意的就是，一旦开启了align-content属性以后，align-items就无效了，就不能在进行单行操作了。</div><div><br/></div><div>这里写的主轴和副轴排布都是绝对的主轴和副轴排布方式，不管主轴和副轴怎么变换，操作主轴的属性始终是操作主轴的。副轴的也一样。</div><div><br/></div><div>五、<span style="color: rgb(255, 0, 0);">我们可以改变子元素在自己当前列上的单独操作</span></div><div>这里我们使用align-self属性来操作，是让每一个子元素在自己当前列上的排布方式。（这个属性是设置给子元素的）</div><div>在开启弹性盒子以后，每一个子元素都会有自己的当前列。（我们设置主轴的排布方式是justify-content: space-between;）</div><div><img src="flex_files/Image [24].png" type="image/png"/></div><div>这里我们用绿色框框起来的就是每个元素自己的当前列，当前列的方向与副轴方向一致（如果副轴方向变成了从左向右，那么当前列就变成了当前行）当前列的长度就是当前副轴的长度，当前列的方向就是副轴的方向。</div><div>这时我们的元素就可以通过align-self属性来改变自己在当前列上面的位置。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>{</div><div>    align-self: flex-start; //-&gt; 让元素在自己的当前列处于开始位</div><div>    align-self: flex-end; //-&gt; 让元素在自己的当前列处于结束位</div><div>    align-self: center; //-&gt; 让元素在自己的当前列处于中间位</div><div>    align-self: stretch; //-&gt; 让元素在自己的当前列处于拉伸状态（在不设置宽高的时候才有效，如果设置了宽高就没有效果了）</div><div>}</div></div><div><br/></div><div>这个没有什么特殊的效果我们就用一张图来演示了。</div><div><img src="flex_files/Image [25].png" type="image/png"/></div><div><br/></div><div>拉伸我们就不做演示了，就是在不设置高（宽）的时候在副轴方向上拉伸至两边顶格。</div><div>刚才看到了一行情况下的元素在当前列的操作，换行以后在设置align-content之前，我们也可以设置当前列的单独操作，但是设置了align-content之后就不可以在进行当前列单独操作了。</div><div><img src="flex_files/Image [26].png" type="image/png"/></div><div><br/></div><div>这个一定是在允许换行后，在设置align-content之前。我们可以设置每一个子元素在当前列上的位置。</div><div>而我们设置了align-content之以后我们的主轴和副轴就会变回只有一条的状态了，这个时候就不允许在进行当前列操作了。</div></span>
</div></body></html> 